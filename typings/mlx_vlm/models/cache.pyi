import mlx.core as mx
import mlx.nn as nn
from _typeshed import Incomplete
from mlx_lm.models.cache import ChunkedKVCache as ChunkedKVCache, _BaseCache
from typing import Any

def make_prompt_cache(model: nn.Module, max_kv_size: int | None = None) -> list[Any]: ...

class SimpleKVCache:
    keys: Incomplete
    values: Incomplete
    cache_length: int
    def __init__(self) -> None: ...
    def update_and_fetch(self, keys, values): ...
    def fetch(self): ...
    def update(self, keys, values) -> None: ...

class SlidingWindowCache(_BaseCache):
    max_size: Incomplete
    step: Incomplete
    keys: Incomplete
    values: Incomplete
    offset: int
    def __init__(self, max_size: int, step: int = 256) -> None: ...
    def update_and_fetch(self, keys: mx.array, values: mx.array) -> tuple[mx.array, mx.array]: ...
    @property
    def state(self): ...
    @state.setter
    def state(self, v) -> None: ...
    def get_max_cache_shape(self): ...
    @property
    def meta_state(self): ...
    @meta_state.setter
    def meta_state(self, v) -> None: ...
    def is_trimmable(self): ...
    def trim(self, n): ...

class StaticKVCache(_BaseCache):
    max_size: Incomplete
    step: Incomplete
    keys: Incomplete
    values: Incomplete
    offset: int
    def __init__(self, max_size: int, step: int = 256) -> None: ...
    def update_and_fetch(self, keys: mx.array, values: mx.array) -> tuple[mx.array, mx.array]: ...
    @property
    def state(self): ...
    @state.setter
    def state(self, v) -> None: ...
    @property
    def meta_state(self): ...
    @meta_state.setter
    def meta_state(self, v) -> None: ...
    def is_trimmable(self): ...
    def trim(self, n): ...
